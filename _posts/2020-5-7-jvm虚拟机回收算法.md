---
layout: post
title:  "jvm虚拟机回收算法"
date:   2020-5-7
categories: java
tags:  java虚拟机
author: Clear Li

---











## 总览图

![image-20200507232857767](/img/image-20200507232857767.png)













## 引用计数法

#### 概述

**给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。**

#### 优缺点

**优点：**

**引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。**

**缺点：**

**无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.而且每次加减非常浪费内存。**



## 标记清除



标记-清除（Mark-Sweep）算法顾名思义，主要就是两个动作，一个是标记，另一个就是清除。

标记就是根据特定的算法（如：引用计数算法，可达性分析算法等）标出内存中哪些对象可以回收，哪些对象还要继续用。

标记指示回收，那就直接收掉；标记指示对象还能用，那就原地不动留下。

**缺点**

**1.** **标记与清除效率低;**

**2.** **清除之后内存会产生大量碎片；**

**所以碎片这个问题还得处理，怎么处理，看标记-整理算法。**





## 复制算法



**S0**和**S1**将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

**复制算法的缺点显而易见，可使用的内存降为原来一半。**

**复制算法用于在新生代垃圾回收**



## 标记-压缩算法



标记压缩法在标记清除基础之上做了优化，把存活的对象压缩到内存一端,而后进行垃圾清理。(java中老年代使用的就是标记压缩法)



## 分代收集算法

根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。

对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.



# 垃圾回收器

![image-20200507232822555](/img/image-20200507232822555.png)

串行回收报告

```
-XX:+PrintGCDetails -Xmx32M -Xms32M
-XX:+HeapDumpOnOutOfMemoryError
-XX:+UseSerialGC
-XX:PermSize=32M

```

![image-20200507230029871](/img/image-20200507230029871.png)

```
-XX:+PrintGCDetails -Xmx512M -Xms32M
-XX:+HeapDumpOnOutOfMemoryError
-XX:+UseSerialGC
-XX:PermSize=32M

```

可见吞吐量（Throughput）显著上升

![image-20200507230740549](/img/image-20200507230740549.png)

可见 ：最大内存越大 ，吞吐量越大

下面调整初始值大小

```
-XX:+PrintGCDetails -Xmx512M -Xms256M
-XX:+HeapDumpOnOutOfMemoryError
-XX:+UseSerialGC
-XX:PermSize=32M

```

![image-20200507231709684](/img/image-20200507231709684.png)

这次发现不但速度快了，而且gc的次数也少了。



下面测试并行回收器（UseParNewGC）

```
-XX:+PrintGCDetails -Xmx512M -Xms256M
-XX:+HeapDumpOnOutOfMemoryError
-XX:+UseParNewGC
-XX:PermSize=32M

```

![image-20200507232403264](/img/image-20200507232403264.png)

速度稍有提升



使用并行合并回收（UseParallelGC）

```
-XX:+PrintGCDetails -Xmx512M -Xms256M
-XX:+HeapDumpOnOutOfMemoryError
-XX:+UseParallelGC
-XX:+UseParallelOldGC
-XX:ParallelGCThreads=8
-XX:PermSize=32M

```

![image-20200507232654949](/img/image-20200507232654949.png)

速度又提升了一大截